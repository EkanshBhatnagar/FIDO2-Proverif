(* FIDO2 WebAuthn authentication protocol with an infected Load Balancer:

   The protocol involves four agents:
   1. Client (typically a browser) - initiates authentication 
   2. Authenticator - hardware/software security key that handles cryptographic operations
   3. Relying Party (RP) - the web server that wants to authenticate the user
   4. Load Balancer (LB) - sits between Client and RP, forwards messages but is compromised

   Communication channels:
   - C_LB: Client to Load Balancer (private but compromised via 'reveal')
   - LB_RP: Load Balancer to Relying Party (private but compromised via 'reveal')
   - A_C: Authenticator to Client (private and secure)
   - reveal: Channel used by Load Balancer to leak information to the attacker

   The protocol flow follows WebAuthn specifications:
   1. Client sends username to RP via LB
   2. RP sends challenge to Client via LB
   3. Client forwards challenge to Authenticator
   4. Authenticator creates signed assertion
   5. Client forwards assertion to RP via LB
   6. RP verifies assertion and issues bearer token

   Security properties test whether authentication remains secure despite the compromised LB.
*)

(* Type declarations for the entities and data involved in the protocol *)
type Username.      (* Username Type *)
type Nonce.         (* Challenge (large random number) *)
type RpId.          (* Relying Party ID *)
type ClientId.      (* Identifying Client - not using *)
type Packet.        
type key.           (* Symmetric key *)
type skey.          (* Secret key for asymmetric encryption *)
type pkey.          (* Public key for asymmetric encryption *)
type sskey.         (* Signing secret key *)
type spkey.         (* Signing public key *)
type AAGUID.        (* Authenticator Attestation GUID - identifies the authenticator model *)

(* Channel declarations *)
free reveal: channel.           (* Channel for the compromised load balancer to leak information *)
table stolen_tokens(bitstring).

(* Private channels for secure communication - Modelling TLS between client, load balancer and relying party. *)
free C_LB: channel [private].   (* Client to Load Balancer *)
free LB_RP: channel [private].  (* Load Balancer to Relying Party *)
free A_C: channel [private].    (* Authenticator to Client *)

(* Function declarations for data conversions and protocol messages *)
fun UsernameToPacket(Username):Packet [typeConverter].

fun Client1(RpId, Nonce): bitstring [data].        (* Client's challenge response *)
fun Auth1(Username, RpId, sskey):bitstring [data]. (* Authenticator credential data *)
fun Auth2(bitstring, AAGUID, bitstring, spkey): bitstring [data]. (* Authenticator data *)
fun Auth3(bitstring,bitstring): bitstring [data].  (* Data to be signed *)

(* Asymmetric encryption functions *)
fun pk(skey): pkey.                           (* Public key derivation from secret key *)
fun aenc(bitstring, pkey): bitstring.         (* Asymmetric encryption *)
reduc forall m: bitstring, sk: skey; adec(aenc(m,pk(sk)),sk) = m. (* Decryption *)

(* Digital signature functions *)
fun spk(sskey):spkey.                         (* Signing public key from signing secret key *)
fun sign(bitstring,sskey): bitstring.         (* Signing function *)
const OK:bitstring.                           (* Success constant *)
fun checksign(bitstring,bitstring,spkey):bitstring
reduc forall m: bitstring, ssk: sskey; checksign(sign(m,ssk),m,spk(ssk)) = OK. (* Signature verification *)

(* Symmetric encryption functions *)
fun senc(bitstring,key):bitstring.            (* Symmetric encryption *)
fun sdec(bitstring,key):bitstring             (* Symmetric decryption *)
reduc forall m:bitstring, k:key; sdec(senc(m,k),k) = m.

(* Constants and cryptographic primitives *)
const bear_token:bitstring [private].         (* Authentication token issued after successful auth *)
fun HMAC(key,bitstring):bitstring.            (* HMAC function for message authentication *)
fun hash(bitstring):bitstring.                (* Hash function *)
fun h(RpId): bitstring.                       (* Special hash for RP ID *)

(* Database tables to store registration data *)
table rp_record(Username, AAGUID, bitstring, spkey). (* RP stores user credentials *)
table auth_record(bitstring).                        (* Authenticator stores credential IDs *)

(* Events for security properties verification *)
event Client_Init_Auth(Username, RpId).                             (* Client initiates auth *)
event Authnr_Finish_Auth(Username,AAGUID,bitstring,spkey).          (* Authenticator finishes auth *)
event Server_Finish_Auth(Username,RpId,AAGUID,bitstring,spkey).     (* Server completes auth *)
event AttackerUsesToken(bitstring).

(* Sanity check variables *)
free sanity1:bitstring [private].
free sanity2:bitstring [private].
free sanity3:bitstring [private].

(* Security queries *)
query attacker(sanity1).     (* Check if sanity1 is revealed by the load balancer *)
(*query attacker(sanity2).*)     (* Check if sanity2 is revealed by the load balancer *)
query t:bitstring; event(AttackerUsesToken(t)).
(*query attacker(bear_token).  (*Check if the bearer token remains secret *)*)
query u:Username, a:AAGUID, c:bitstring, pkau:spkey; event(Authnr_Finish_Auth(u,a,c,pkau)). (* Check if authenticator auth events occur *)

query u:Username, r:RpId, a:AAGUID, c:bitstring, pkau:spkey; event(Server_Finish_Auth(u,r,a,c,pkau)). (* Check if server auth events occur *)

(* Authentication property: if server completes auth, client must have initiated it *)
query u:Username, r:RpId, a:AAGUID, c:bitstring, pkau:spkey; 
event(Server_Finish_Auth(u,r,a,c,pkau)) ==> event(Client_Init_Auth(u,r)).

(* Authentication property: if server completes auth, authenticator must have completed its part *)
query u:Username, r:RpId, a:AAGUID, c:bitstring, pkau:spkey; 
event(Server_Finish_Auth(u,r,a,c,pkau)) ==> event(Authnr_Finish_Auth(u,a,c,pkau)).

(* Authentication property: complete authentication chain *)
query u:Username, r:RpId, a:AAGUID, c:bitstring, pkau:spkey; 
event(Server_Finish_Auth(u,r,a,c,pkau)) ==> (event(Authnr_Finish_Auth(u,a,c,pkau)) ==> event(Client_Init_Auth(u,r))).

(* Relying Party Authentication Process *)
let RP_Auth(rpid:RpId) =
    (* Receive username from load balancer *)
    in(LB_RP, username:Username);
    (* Look up user's registered credentials *)
    get rp_record(=username, aaguid, credID, pkA) in
    (* Generate a challenge nonce *)
    new challenge:Nonce;
    (* Send challenge to client via load balancer *)
    out(LB_RP, (rpid, challenge, credID));
    (* Receive client's authentication response *)
    in(LB_RP, (aData:bitstring, sig:bitstring, cdata:bitstring));
    (* Verify challenge response data *)
    if Client1(rpid, challenge) = cdata then
    (* Verify authenticator data *)
    let Auth2(h_rpid, aaguid, credID, pkA) = aData in
    (* Verify RP ID hash *)
    if h_rpid = h(rpid) then
    (* Verify signature *)
    if checksign(sig, Auth3(aData,hash(cdata)), pkA) = OK then
    (* Record successful authentication event *)
    out(LB_RP, bear_token);
    event Server_Finish_Auth(username,rpid,aaguid,credID,pkA)
    (* Issue bearer token to client *)
    
.

(* Client Authentication Process *)
let Client_Auth(client_id:ClientId, pinUVAuthToken:key, username:Username) =
    (* Send username to RP via load balancer *)
    out(C_LB, username);
    (* Receive challenge from RP *)
    in(C_LB, (rpid:RpId, challenge:Nonce, credID:bitstring));
    (* Create client data containing challenge response *)
    let cdata = Client1(rpid, challenge) in
    (* Create PIN/UV auth token for the authenticator *)
    let pinAuth = (HMAC(pinUVAuthToken,hash(cdata))) in
    (* Record client authentication initiation *)
    event Client_Init_Auth(username, rpid);
    (* Send data to authenticator *)
    out(A_C, (hash(cdata), credID, pinAuth));
    (* Receive signed response from authenticator *)
    in(A_C, (aData:bitstring, sig:bitstring));
    (* Forward authenticator response to RP via load balancer *)
    out(C_LB, (aData, sig, cdata));
    (* Receive access token from RP *)
    in(C_LB, access_token:bitstring)
.

(* Authenticator Authentication Process *)
let Auth_Auth(aaguid:AAGUID, wk:key, pinAuthToken:key) = 
    (* Receive request from client *)
    in(A_C, (hcdata:bitstring, credID:bitstring, pinAuth:bitstring));
    (* Verify credential ID exists in authenticator storage *)
    get auth_record(x) suchthat x = credID in
    (* Verify PIN/UV auth token *)
    if pinAuth = HMAC(pinAuthToken, hcdata) then
    (* Decrypt credential ID to get user info and private key *)
    let Auth1(username, rpid, skA) = sdec(credID, wk) in
    (* Create authenticator data *)
    let aData = Auth2(h(rpid), aaguid, credID, spk(skA)) in
    (* Sign the combined authenticator data and client data hash *)
    let sig = sign(Auth3(aData,hcdata),skA) in
    (* Record successful authenticator verification *)
    event Authnr_Finish_Auth(username,aaguid,credID,spk(skA));
    (* Send signed response back to client *)
    out(A_C, (aData, sig))
.   

(* Load Balancer Process - with malicious intent *)
let LoadBalancer() =
    (
        (* Behavior 1: Relay traffic and steal the bear token *)
        in(C_LB, username:Username);
        out(reveal, username);
        out(LB_RP, username);
        in(LB_RP, (rpid:RpId, challenge:Nonce, credID:bitstring));
        out(reveal, (rpid, challenge, credID));
        out(C_LB, (rpid, challenge, credID));
        in(C_LB, (aData:bitstring, sig:bitstring, cdata:bitstring));
        out(reveal, (aData, sig, cdata));
        out(LB_RP, (aData, sig, cdata));
        in(LB_RP, token:bitstring);

        (* The load balancer reveals the token AND stores it for later *)
        out(reveal, token);
        insert stolen_tokens(token);

        out(C_LB, token)
    )
    |
    (
        get stolen_tokens(stolen_token:bitstring) in
        event AttackerUsesToken(stolen_token)
    )
.

(* Main Process *)
process
    (* Initialize system parameters *)
    new rpid:RpId;
    new clientid:ClientId;
    new pinAuth:key;          (* PIN/UV Auth Token *)
    new wk:key;               (* Wrapping key for credential storage *)
    new aaguid:AAGUID;        (* Authenticator identifier *)
    new username:Username;
    new skA:sskey;            (* User's signing key *)
    (* Create encrypted credential *)
    let credID = senc(Auth1(username, rpid, skA), wk) in
    (* Store credential in RP and authenticator databases *)
    insert rp_record(username, aaguid, credID, spk(skA));
    insert auth_record(credID);
    (* Start parallel processes: RP, Client, Authenticator, and LoadBalancer *)
    !RP_Auth(rpid) | !Client_Auth(clientid, pinAuth, username) | !Auth_Auth(aaguid, wk, pinAuth) | (!LoadBalancer())