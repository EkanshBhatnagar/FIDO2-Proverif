(* This model implements the FIDO2 WebAuthn authentication protocol with secure direct communication.
   The protocol involves three entities:
   1. Client (user agent, typically a browser) - initiates authentication 
   2. Authenticator - hardware/software security key that handles cryptographic operations
   3. Relying Party (RP) - the web server that wants to authenticate the user

   Communication channels:
   - C_RP: Client to Relying Party (private and secure)
   - A_C: Authenticator to Client (private and secure)
   - reveal: Channel (not used in this secure model)

   The protocol flow follows WebAuthn specifications:
   1. Client sends username to RP directly
   2. RP sends challenge to Client directly
   3. Client forwards challenge to Authenticator
   4. Authenticator creates signed assertion
   5. Client forwards assertion to RP directly
   6. RP verifies assertion and issues bearer token

*)

(* Type declarations for the entities and data involved in the protocol *)
type Username.      (* Username Type *)
type Nonce.         (* Challenge (large random number) *)
type RpId.          (* Relying Party ID *)
type ClientId.      (* Identifying Client - not using *)
type Packet.        
type key.           (* Symmetric key *)
type skey.          (* Secret key for asymmetric encryption *)
type pkey.          (* Public key for asymmetric encryption *)
type sskey.         (* Signing secret key *)
type spkey.         (* Signing public key *)
type AAGUID.        (* Authenticator Attestation GUID - identifies the authenticator model *)

(* Channel declarations *)
free reveal: channel.         (* Channel for revealing data - not used in this secure model *)
(* Private channels for secure communication - Modelling TLS *)
free C_RP: channel . (* Client to Relying Party - direct secure channel *)
free A_C: channel [private].  (* Authenticator to Client *)

(* Function declarations for data conversions and protocol messages *)
fun UsernameToPacket(Username):Packet [typeConverter].
fun Client1(RpId, Nonce): bitstring [data].        (* Client's challenge response *)
fun Auth1(Username, RpId, sskey):bitstring [data]. (* Authenticator credential data *)
fun Auth2(bitstring, AAGUID, bitstring, spkey): bitstring [data]. (* Authenticator data *)
fun Auth3(bitstring,bitstring): bitstring [data].  (* Data to be signed *)

(* Asymmetric encryption functions *)
fun pk(skey): pkey.                           (* Public key derivation from secret key *)
fun aenc(bitstring, pkey): bitstring.         (* Asymmetric encryption *)
reduc forall m: bitstring, sk: skey; adec(aenc(m,pk(sk)),sk) = m. (* Decryption *)

(* Digital signature functions *)
fun spk(sskey):spkey.                         (* Signing public key from signing secret key *)
fun sign(bitstring,sskey): bitstring.         (* Signing function *)
const OK:bitstring.                           (* Success constant *)
fun checksign(bitstring,bitstring,spkey):bitstring
reduc forall m: bitstring, ssk: sskey; checksign(sign(m,ssk),m,spk(ssk)) = OK. (* Signature verification *)

(* Symmetric encryption functions *)
fun senc(bitstring,key):bitstring.            (* Symmetric encryption *)
fun sdec(bitstring,key):bitstring             (* Symmetric decryption *)
reduc forall m:bitstring, k:key; sdec(senc(m,k),k) = m.

(* Constants and cryptographic primitives *)
const bear_token:bitstring [private].         (* Authentication token issued after successful auth *)
fun HMAC(key,bitstring):bitstring.            (* HMAC function for message authentication *)
fun hash(bitstring):bitstring.                (* Hash function *)
fun h(RpId): bitstring.                       (* Special hash for RP ID *)

(* Database tables to store registration data *)
table rp_record(Username, AAGUID, bitstring, spkey). (* RP stores user credentials *)
table auth_record(bitstring).                        (* Authenticator stores credential IDs *)

(* Events for security properties verification *)
event Client_Init_Auth(Username, RpId).                             (* Client initiates auth *)
event Authnr_Finish_Auth(Username,AAGUID,bitstring,spkey).          (* Authenticator finishes auth *)
event Server_Finish_Auth(Username,RpId,AAGUID,bitstring,spkey).     (* Server completes auth *)

(* Sanity check variables *)
free sanity1:bitstring [private].
free sanity2:bitstring [private].
free sanity3:bitstring [private].

(* Security queries *)
query attacker(sanity1).     (* Check if sanity1 can be obtained by the attacker *)
query attacker(sanity2).     (* Check if sanity2 can be obtained by the attacker *)

query attacker(bear_token).  (* Check if the bearer token remains secret *)
query u:Username, a:AAGUID, c:bitstring, pkau:spkey; event(Authnr_Finish_Auth(u,a,c,pkau)). (* Check if authenticator auth events occur *)

query u:Username, r:RpId, a:AAGUID, c:bitstring, pkau:spkey; event(Server_Finish_Auth(u,r,a,c,pkau)). (* Check if server auth events occur *)

(* Authentication property: if server completes auth, client must have initiated it *)
query u:Username, r:RpId, a:AAGUID, c:bitstring, pkau:spkey; 
inj-event(Server_Finish_Auth(u,r,a,c,pkau)) ==> inj-event(Client_Init_Auth(u,r)).

(* Authentication property: if server completes auth, authenticator must have completed its part *)
query u:Username, r:RpId, a:AAGUID, c:bitstring, pkau:spkey; 
inj-event(Server_Finish_Auth(u,r,a,c,pkau)) ==> inj-event(Authnr_Finish_Auth(u,a,c,pkau)).

(* Authentication property: complete authentication chain *)
query u:Username, r:RpId, a:AAGUID, c:bitstring, pkau:spkey; 
inj-event(Server_Finish_Auth(u,r,a,c,pkau)) ==> (inj-event(Authnr_Finish_Auth(u,a,c,pkau)) ==> inj-event(Client_Init_Auth(u,r))).

(* Relying Party Authentication Process *)
let RP_Auth(rpid:RpId) =
    (* Receive username directly from client *)
    in(C_RP, username:Username);
    (* Look up user's registered credentials *)
    get rp_record(=username, aaguid, credID, pkA) in
    (* Generate a challenge nonce *)
    new challenge:Nonce;
    (* Send challenge directly to client *)
    out(C_RP, (rpid, challenge, credID));
    (* Receive client's authentication response *)
    in(C_RP, (aData:bitstring, sig:bitstring, cdata:bitstring));
    (* Verify challenge response data *)
    if Client1(rpid, challenge) = cdata then
    (* Verify authenticator data *)
    let Auth2(h_rpid, aaguid, credID, pkA) = aData in
    (* Verify RP ID hash *)
    if h_rpid = h(rpid) then
    (* Verify signature *)
    if checksign(sig, Auth3(aData,hash(cdata)), pkA) = OK then
    (* Record successful authentication event *)
    event Server_Finish_Auth(username,rpid,aaguid,credID,pkA);
    (* Issue bearer token to client *)
    out(C_RP, bear_token)
.

(* Client Authentication Process *)
let Client_Auth(client_id:ClientId, pinUVAuthToken:key, username:Username) =
    (* Send username directly to RP *)
    out(C_RP, username);
    (* Receive challenge from RP *)
    in(C_RP, (rpid:RpId, challenge:Nonce, credID:bitstring));
    (* Create client data containing challenge response *)
    let cdata = Client1(rpid, challenge) in
    (* Create PIN/UV auth token for the authenticator *)
    let pinAuth = (HMAC(pinUVAuthToken,hash(cdata))) in
    (* Record client authentication initiation *)
    event Client_Init_Auth(username, rpid);
    (* Send data to authenticator *)
    out(A_C, (hash(cdata), credID, pinAuth));
    (* Receive signed response from authenticator *)
    in(A_C, (aData:bitstring, sig:bitstring));
    (* Forward authenticator response directly to RP *)
    out(C_RP, (aData, sig, cdata));
    (* Receive access token from RP *)
    in(C_RP, access_token:bitstring)
.

(* Authenticator Authentication Process *)
let Auth_Auth(aaguid:AAGUID, wk:key, pinAuthToken:key) = 
    (* Receive request from client *)
    in(A_C, (hcdata:bitstring, credID:bitstring, pinAuth:bitstring));
    (* Verify credential ID exists in authenticator storage *)
    get auth_record(x) suchthat x = credID in
    (* Verify PIN/UV auth token *)
    if pinAuth = HMAC(pinAuthToken, hcdata) then
    (* Decrypt credential ID to get user info and private key *)
    let Auth1(username, rpid, skA) = sdec(credID, wk) in
    (* Create authenticator data *)
    let aData = Auth2(h(rpid), aaguid, credID, spk(skA)) in
    (* Sign the combined authenticator data and client data hash *)
    let sig = sign(Auth3(aData,hcdata),skA) in
    (* Record successful authenticator verification *)
    event Authnr_Finish_Auth(username,aaguid,credID,spk(skA));
    (* Send signed response back to client *)
    out(A_C, (aData, sig))
.   

(* Main Process *)
process
    (* Initialize system parameters *)
    new rpid:RpId;
    new clientid:ClientId;
    new pinAuth:key;          (* PIN/UV Auth Token *)
    new wk:key;               (* Wrapping key for credential storage *)
    new aaguid:AAGUID;        (* Authenticator identifier *)
    new username:Username;
    new skA:sskey;            (* User's signing key *)
    (* Create encrypted credential *)
    let credID = senc(Auth1(username, rpid, skA), wk) in
    (* Store credential in RP and authenticator databases *)
    insert rp_record(username, aaguid, credID, spk(skA));
    insert auth_record(credID);
    (* Start parallel processes: RP, Client, and Authenticator - no Load Balancer *)
    RP_Auth(rpid) | Client_Auth(clientid, pinAuth, username) | Auth_Auth(aaguid, wk, pinAuth)